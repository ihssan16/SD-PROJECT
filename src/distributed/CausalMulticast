import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class CausalMulticast {

    private VectorClock localVC;
    private List<Message> causalBuffer;
    private int myId;

    public CausalMulticast(int myId, int numberOfNodes) {
        this.myId = myId;
        this.localVC = new VectorClock(numberOfNodes);
        this.causalBuffer = new ArrayList<>();
    }

    
/*     Réception d’un message      */
    public synchronized void onReceive(Message msg) {
        if (canDeliver(msg)) {
            deliver(msg);
            checkBuffer();
        } else {
            causalBuffer.add(msg);
            System.out.println("[BUFFERED] " + msg);
        }
    }

/*     Règle de livraison causal      */
    private boolean canDeliver(Message msg) {
        VectorClock msgVC = msg.getVectorClock();
        int sender = msg.getSenderId();

        // Condition 1 : prochain message attendu de l’émetteur
        if (msgVC.get(sender) != localVC.get(sender) + 1) {
            return false;
        }

        // Condition 2 : toutes les autres dépendances satisfaites
        for (int i = 0; i < msgVC.size(); i++) {
            if (i != sender && msgVC.get(i) > localVC.get(i)) {
                return false;
            }
        }
        return true;
    }

/*    Livraison d’un message     */
    private void deliver(Message msg) {
        System.out.println(
            "[DELIVERED] Node " + myId +
            " <- " + msg.getSenderId() +
            " | VC=" + msg.getVectorClock() +
            " | Content=" + msg.getContent()
        );

        // Mise à jour de l’horloge locale
        localVC.updateOnReceive(msg.getVectorClock());
    }

/*     Vérification du buffer      */
    private void checkBuffer() {
        boolean progress;

        do {
            progress = false;
            Iterator<Message> iterator = causalBuffer.iterator();

            while (iterator.hasNext()) {
                Message msg = iterator.next();
                if (canDeliver(msg)) {
                    deliver(msg);
                    iterator.remove();
                    progress = true;
                }
            }
        } while (progress);
    }

/*       Multicast causal        */
    public synchronized Message broadcast(String content) {
        localVC.increment(myId);

        Message msg = new Message(myId, content);
        msg.setVectorClock(localVC.copy());

        return msg;
    }
}
